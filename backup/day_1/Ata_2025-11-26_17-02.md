# üìò Relat√≥rio T√©cnico de Implementa√ß√£o: FamilyOS (M√≥dulo de Compras)

**Vers√£o:** 1.0 (MVP Funcional)
**Status:** ‚úÖ Operacional
**Foco:** Fric√ß√£o Zero (Voice-to-Database)

-----

## 1\. Vis√£o Geral da Arquitetura

Constru√≠mos um sistema h√≠brido que une a facilidade da Nuvem (Telegram/n8n) com o poder e controle do processamento Local (Python/Gemini).

**O Fluxo da Informa√ß√£o:**

### ‚öôÔ∏è Estrutura do Data Pipeline (Texto para Relat√≥rio)

1.  **Collection / Coleta**
    * *Fun√ß√£o:* Recebimento do dado inicial.
    * *Componente:* **Telegram (√Åudio/Texto)**.

2.  **Ingestion / Ingest√£o**
    * *Fun√ß√£o:* Entrada segura no sistema e in√≠cio do processamento.
    * *Componente:* **n8n (Telegram Trigger)** e **Ngrok (T√∫nel)**.

3.  **Preparation / Prepara√ß√£o**
    * *Fun√ß√£o:* Transcri√ß√£o do √°udio e limpeza do texto.
    * *Componente:* **OpenAI Whisper / Gemini Transcribe** (dentro do n8n).

4.  **Computation / Computa√ß√£o**
    * *Fun√ß√£o:* Interpreta√ß√£o de linguagem natural e extra√ß√£o de dados estruturados (NLP).
    * *Componente:* **API Flask (`/magic`)** rodando **Gemini Lite (LangChain)**.

5.  **Presentation / Persist√™ncia**
    * *Fun√ß√£o:* Armazenamento da informa√ß√£o e prepara√ß√£o para consumo.
    * *Componente:* **SQLAlchemy / SQLite** (tabela `lista_itens`) e **Notion** (futuro frontend de visualiza√ß√£o).

---

1.  **Interface (Frontend):** Telegram (√Åudio ou Texto).
2.  **Orquestrador (Middleware):** n8n (Recebe, transcreve e encaminha).
3.  **T√∫nel (Infra):** Ngrok (Exp√µe o localhost para a internet segura).
4.  **C√©rebro (Backend):** Python Flask + Google Gemini (Interpreta e Estrutura).
5.  **Mem√≥ria (Database):** SQLite (Armazena de forma relacional).

-----

## 2\. Detalhamento dos Componentes

### A. A Porta de Entrada (Telegram & n8n)

No n8n, criamos um fluxo inteligente que lida com dois tipos de dados:

  * **Texto:** Passa direto.
  * **√Åudio:** Passa pelo n√≥ **OpenAI Whisper** para transcri√ß√£o.
  * **L√≥gica de Envio:** Um n√≥ `HTTP Request` unifica tudo. Usamos uma express√£o l√≥gica para enviar o texto, independente da origem:
    ```javascript
    {{ $json.text || $json.message.text }}
    ```
  * **Identifica√ß√£o:** Capturamos dinamicamente quem est√° falando (`message.from.first_name`), permitindo que o sistema saiba se √© o "Thiago" ou a "Esposa".

### B. A Ponte (Ngrok)

Como seu servidor Python roda dentro da sua rede dom√©stica (atr√°s de roteadores e firewalls), usamos o **Ngrok** para criar um t√∫nel HTTPS seguro.

  * **Fun√ß√£o:** Criar uma URL p√∫blica (`https://....ngrok-free.app`) que redireciona o tr√°fego para `localhost:5000`.
  * **Seguran√ßa:** O tr√°fego √© criptografado ponta a ponta.

### C. O C√©rebro (Python Flask + Gemini)

O arquivo `src/app.py` evoluiu de um script simples para um **Microservi√ßo de Intelig√™ncia**.

  * **Rota `/magic`:** O cora√ß√£o do sistema.
    1.  Recebe o texto bruto ("comprar caf√© e leite").
    2.  Aciona o **Google Gemini 2.5 Flash-Lite** via LangChain.
    3.  **Prompt Engineering:** Instru√≠mos a IA a retornar uma lista JSON estrita, extraindo `nome`, `quantidade`, `unidade` e `categoria`.
    4.  **Tratamento de Erro:** Implementamos regex para limpar marcadores Markdown (\`\`\`json) que a IA adora colocar.

### D. A Persist√™ncia (SQLAlchemy + SQLite)

N√£o jogamos dados soltos. Criamos um banco relacional robusto em `todo_market.db`.

  * **Tabela `produtos` (Cat√°logo):** Guarda o cadastro √∫nico do item (ex: "Leite Integral"). Se o item j√° existe, n√£o duplicamos.
  * **Tabela `lista_itens` (Carrinho):** Guarda a inten√ß√£o de compra. Aqui registramos:
      * Quantidade (ex: 2).
      * Unidade (ex: Litros).
      * Usu√°rio (ex: Thiago).
      * Data e Hora.

-----

## 3\. O Fluxo "M√°gico" Passo a Passo

Quando voc√™ mandou o √°udio **"Comprar 2 litros de leite"**, aconteceu o seguinte em milissegundos:

1.  **Telegram** entregou o arquivo `.oga` para o n8n.
2.  **n8n** enviou para a OpenAI, que devolveu o texto: *"Comprar 2 litros de leite"*.
3.  **n8n** montou o JSON: `{"texto": "Comprar 2 litros de leite", "usuario": "Thiago"}` e disparou para o Ngrok.
4.  **Flask** recebeu o JSON na rota `/magic`.
5.  **Gemini** analisou e extraiu:
      * `nome`: "leite"
      * `quantidade`: 2
      * `unidade`: "L"
      * `categoria`: "Padaria" (Inferido pela IA).
6.  **Python** verificou no banco: "Leite j√° existe?". Sim. Pegou o ID.
7.  **Python** inseriu na tabela `lista_itens`: "Thiago quer 2L do produto ID X".
8.  **Flask** retornou: `201 Created - Sucesso`.
9.  **n8n** recebeu o sucesso e mandou mensagem no Telegram: *"‚úÖ Sucesso\! Thiago adicionou: leite"*.

-----

## 4\. Conquistas T√©cnicas & Valor Entregue

| Desafio | Solu√ß√£o Implementada | Resultado |
| :--- | :--- | :--- |
| **Conectividade** | Ngrok (T√∫nel) | Seu PC virou um servidor web acess√≠vel globalmente. |
| **Intelig√™ncia** | Gemini + LangChain | O sistema "entende" linguagem natural, n√£o precisa de comandos r√≠gidos. |
| **Integridade** | SQLAlchemy (ORM) | Dados normalizados. Cat√°logo separado da Lista. |
| **Usabilidade** | Voice-to-Text | **Fric√ß√£o Zero.** Basta falar, sem digitar nada. |

-----

## 5\. Pr√≥ximos Passos (Vis√£o de Futuro)

Agora que o dado entra f√°cil, ele precisa sair f√°cil.

1.  **Sprint 3 (Visualiza√ß√£o):** Conectar esse banco de dados ao **Notion** (ou criar uma interface web simples) para que a lista seja "tic√°vel" no mercado.
2.  **Deploy Real:** Tirar do seu PC e colocar num servidor (VPS ou Render) para n√£o depender do seu computador ligado e do Ngrok aberto.

